<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>file.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Bucket.html">Bucket</a><ul class='methods'><li data-type='method'><a href="Bucket.html#create">create</a></li><li data-type='method'><a href="Bucket.html#exists">exists</a></li><li data-type='method'><a href="Bucket.html#file">file</a></li><li data-type='method'><a href="Bucket.html#getIndex">getIndex</a></li><li data-type='method'><a href="Bucket.html#getMetadata">getMetadata</a></li><li data-type='method'><a href="Bucket.html#indexFile">indexFile</a></li><li data-type='method'><a href="Bucket.html#open">open</a></li></ul></li><li><a href="File.html">File</a><ul class='methods'><li data-type='method'><a href="File.html#create">create</a></li><li data-type='method'><a href="File.html#exists">exists</a></li><li data-type='method'><a href="File.html#getLastchange">getLastchange</a></li><li data-type='method'><a href="File.html#getMetadata">getMetadata</a></li><li data-type='method'><a href="File.html#open">open</a></li><li data-type='method'><a href="File.html#read">read</a></li><li data-type='method'><a href="File.html#save">save</a></li></ul></li><li><a href="Gpgfs.html">Gpgfs</a><ul class='methods'><li data-type='method'><a href="Gpgfs.html#bucket">bucket</a></li><li data-type='method'><a href="Gpgfs.html#cacheWhoami">cacheWhoami</a></li><li data-type='method'><a href="Gpgfs.html#getBuckets">getBuckets</a></li><li data-type='method'><a href="Gpgfs.html#open">open</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">file.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const md5 = require('md5')
const Path = require('path')
const crypto = require('crypto')
const Hoek = require('@hapi/hoek')
const ObjectId = require('bson-objectid')
const debug = require('debug')('gpgfs.File')

const Utils = require('./utils')

  /** Class representing gpgfs File */
class File {
  
  /** @hideconstructor */
  constructor({bucket, id, filePath}){
    this.bucket = bucket
    this.id = new ObjectId(id)
    this.filePath = Path.normalize( filePath )

    this.content = ''
    this.metadata = null
    this.lastchange = null
  }

  /**
   * Open and read metadata 
   * @method */
  async open(){
    await this.getMetadata()
    await this.getLastchange()
    this.filePath = this.metadata.path
    debug('loaded ', this.filePath)
  }

  /**
   * Check if all metadata and content exists on disk
   * @method
   * @returns {boolean} */
  exists(){
    const contentExists = this.bucket.root.fileExists( this.path )
    const metadataExists = this.bucket.root.fileExists( this.lastchangePath )
    const lastchangeExists = this.bucket.root.fileExists( this.path )

    return contentExists
  }

  get path(){
    return Path.join(
      this.bucket.path,
      'objects/object-' + this.id.toHexString()
    )
  }

  get metadataPath(){
    return Path.join(
      this.bucket.path,
      'object-meta/object-' + this.id.toHexString() +'-meta'
    )
  }

  get lastchangePath(){
    return Path.join(
      this.bucket.path,
      'object-lastchange/object-' + this.id.toHexString() +'-lastchange'
    )
  }

  /**
   * Create file if it does not exist 
   * @method
   * @param {string} [value=''] Content to save in file
   */
  async create(value){
    debug('create -', this.id)
    if(this.exists()){ throw new Error('file exists') }

    await this.setMetadata()
    await this.save(value)
  }

  async getReciepents(){
    await this.bucket.root.cacheWhoami()
    const bucketToList = await this.bucket.getReciepents()
    let toList = [ ...bucketToList ]

    if(this.metadata){

      if(this.metadata.meta &amp;&amp; this.metadata.meta.length > 0){
        toList = toList.concat(this.metadata.meta)
      }

      if(this.metadata.readers &amp;&amp; this.metadata.readers.length > 0){
        toList = toList.concat(this.metadata.readers)
      }

      if(this.metadata.writers &amp;&amp; this.metadata.writers.length > 0){
        toList = toList.concat(this.metadata.writers)
      }

    }

    return Utils.uniqueArray(toList)
  }

  /**
   * Read content from file 
   * @method
   * @returns {string}
   */
  async read(){
    //load &amp; decrypt
    this.content = await this.bucket.root.readFile( this.path, true)
    return this.content
  }

  /**
   * Write content to file. Update metadata and re-index file in bucket index.
   * @method 
   * @param {string} [newContent=this.content]
   */
  async save(newContent=null){

    const contentReaders = Utils.uniqueArray(
      [ this.metadata.owner ].concat(
        this.metadata.readers,
        this.metadata.writers
      )
    )

    if(newContent){
      this.content = newContent
    }

    await this.bucket.root.writeFile( this.path,
      this.content,
      {
        encrypt: true,
        to: contentReaders
      }
    )

    await this.updateLastChange()

    await this.bucket.indexFile(this)
  }

  /**
   * File metadata 
   * @method 
   * @returns {gpgfs_model.object_meta} See [`gpgfs_model.object_meta`]{@link https://github.com/datapartyjs/gpgfs-model/blob/master/src/types/object_meta.js}
   */
  async getMetadata(){
    this.metadata = await this.bucket.root.readFile( this.metadataPath, true, 'object_meta')
    return this.metadata
  }

  async setMetadata(){
    const toList = await this.getReciepents()
    const nowTime = (new Date()).toISOString()
    let newMetadata = Object.assign({lastchanged: nowTime}, {
      owner: this.bucket.metadata.owner,
      path: Path.normalize( this.filePath ),
      bucketId: {
        id: this.bucket.id.toHexString(),
        type: 'bucket_meta'
      },
      objectId: {
        id: this.id.toHexString(),
        type: 'object_meta'
      },
      created: Hoek.reach(this, 'metadata.created') || nowTime,
      cleartext: Hoek.reach(this, 'bucket.metadata.cleartext'),
      meta: Hoek.reach(this, 'bucket.metadata.meta'),
      readers: Hoek.reach(this, 'bucket.metadata.readers'),
      writers: Hoek.reach(this, 'bucket.metadata.writers')
    })

    await this.bucket.root.writeFile( this.metadataPath,
      newMetadata,
      {
        model: 'object_meta',
        encrypt: true,
        to: await this.getReciepents()
      }
    )

    if(!this.metadata){
      debug('creating metadata')
      this.metadata = newMetadata
    }
    else {
      debug('replacing metadata')
      this.metadata = newMetadata
    }
  }

  /**
   * Last change metadata 
   * @method 
   * @returns {gpgfs_model.object_lastchange} See [`gpgfs_model.object_lastchange`]{@link https://github.com/datapartyjs/gpgfs-model/blob/master/src/types/object_lastchange.js}
   */
  async getLastchange(){
    this.lastchange = await this.bucket.root.readFile( this.lastchangePath, true, 'object_lastchange')
    return this.lastchange  
  }
  
  async updateLastChange(){
    const nowTime = (new Date()).toISOString()

    //const md5sum = md5(this.content)
    const hash = {
      sha256: crypto.createHash('sha256').update(this.content).digest('hex')
    }

    await this.bucket.root.cacheWhoami()

    let newLastchange = Object.assign({lastchanged: nowTime}, {
      bucketId: {
        id: this.bucket.id.toHexString(),
        type: 'bucket_meta'
      },
      objectId: {
        id: this.id.toHexString(),
        type: 'object_meta'
      },
      size: this.content.length,
      actor: this.bucket.root.whoami,
      hash
    })

    debug('updateLastChange -', newLastchange)

    await this.bucket.root.writeFile( this.lastchangePath,
      newLastchange,
      {
        model: 'object_lastchange',
        encrypt: true,
        to: await this.getReciepents()
      }
    )

    if(!this.lastchange){
      debug('creating lastchange')
      this.lastchange = newLastchange
    }
    else {
      debug('replacing lastchange')
      this.lastchange = newLastchange
    }

  }

  async assertIsTrusted(){}

  async assertIsMetaTrusted(){
    /*
      - is the verification signer an owner?
      - is the verficiation signer a writer?
    */
  }
}

module.exports = File</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> on Sat Jan 11 2020 09:22:43 GMT-0800 (Pacific Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
