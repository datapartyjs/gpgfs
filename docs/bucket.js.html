<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>bucket.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Bucket.html">Bucket</a><ul class='methods'><li data-type='method'><a href="Bucket.html#create">create</a></li><li data-type='method'><a href="Bucket.html#exists">exists</a></li><li data-type='method'><a href="Bucket.html#file">file</a></li><li data-type='method'><a href="Bucket.html#getIndex">getIndex</a></li><li data-type='method'><a href="Bucket.html#getMetadata">getMetadata</a></li><li data-type='method'><a href="Bucket.html#indexFile">indexFile</a></li><li data-type='method'><a href="Bucket.html#open">open</a></li></ul></li><li><a href="File.html">File</a><ul class='methods'><li data-type='method'><a href="File.html#create">create</a></li><li data-type='method'><a href="File.html#exists">exists</a></li><li data-type='method'><a href="File.html#getLastchange">getLastchange</a></li><li data-type='method'><a href="File.html#getMetadata">getMetadata</a></li><li data-type='method'><a href="File.html#open">open</a></li><li data-type='method'><a href="File.html#read">read</a></li><li data-type='method'><a href="File.html#save">save</a></li></ul></li><li><a href="FsStorage.html">FsStorage</a></li><li><a href="GCEStorage.html">GCEStorage</a></li><li><a href="Gpgfs.html">Gpgfs</a><ul class='methods'><li data-type='method'><a href="Gpgfs.html#bucket">bucket</a></li><li data-type='method'><a href="Gpgfs.html#cacheWhoami">cacheWhoami</a></li><li data-type='method'><a href="Gpgfs.html#getBuckets">getBuckets</a></li><li data-type='method'><a href="Gpgfs.html#open">open</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#S_IFMT">S_IFMT</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">bucket.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const Path = require('path')
const Hoek = require('@hapi/hoek')
const ObjectId = require('bson-objectid')
const debug = require('debug')('gpgfs.Bucket')

const Utils = require('./utils')
const GpgFsFile = require('./file')

/** Class representing gpgfs Bucket */
class Bucket {


  /** @hideconstructor */
  constructor({id, name, root}){
    this.id = new ObjectId(id)
    this.name = name
    this.root = root

    this.index = null
    this.metadata = null
    this._fileCache = {}
    debug('new -', name || id)
  }

  /**
   * Open and read metadata 
   * @method */
  async open(){
    this.index = null
    this.metadata = null
    this._fileCache = {}
    await this.getIndex()
    await this.getMetadata()
    this.name = this.metadata.bucketName
    debug('loaded ', this.name)
  }

  async release(){
    debug('releasing', this.id.toString())

    for(let id in this._fileCache){
      await this._fileCache[id].release()

      delete this._fileCache[id].bucket
      this._fileCache[id].bucket = null
      delete this._fileCache[id]
    }

    delete this.index
    delete this.metadata
    delete this._fileCache

    this.index = null
    this.metadata = null
    this._fileCache = {}
  }

  async releaseFile(file){
    delete this._fileCache[file.id.toString()]
    this._fileCache[file.id.toString()] = undefined
  }

  /**
   * Check if all metadata exists on disk
   * @method
   * @returns {boolean} */
  async exists(){
    const existance = await Promise.all([
      this.root.fileExists( this.indexPath ),
      this.root.fileExists( this.metadataPath )
    ])
    
    return existance.reduce(
      (total, current)=>{ return total &amp;&amp; current },
      true
    )
  }

    /**
   * Create bucket if it does not exist 
   * @method
   */
  async create(){
    debug('create -', this.id)

    //if(this.exists()){ throw new Error('bucket exists') }
    if(await this.root.fileExists( this.indexPath )){ throw new Error('bucket index exists') }
    if(await this.root.fileExists( this.metadataPath )){ throw new Error('bucket metadata exists') }

    this.root.touchDir(this.path)
    this.root.touchDir(this.path + '/objects')
    this.root.touchDir(this.path + '/object-meta')
    this.root.touchDir(this.path + '/object-lastchange')

    const nowTime = (new Date()).toISOString()

    const whoami = (await this.root.keychain.whoami())[0]

    await this.setMetadata({
      owner: whoami,
      bucketId: {
        id: this.id.toHexString(),
        type: 'bucket_meta'
      },
      created: nowTime,
      bucketName: this.name,
      cleartext: false,
      meta: [whoami],
      readers: [whoami],
      writers: [whoami]
    })

    await this.setIndex({
      created: nowTime
    })
  }

  /** 
   * Get a file instance
   * @method
   * @param {string} name File path
   * @returns {File}
   */
  async file(name){
    let file = await this.getFile(name)

    if(!file){
      file = new GpgFsFile({
        bucket: this,
        filePath: name
      })
    }

    return file
  }

  async getFileFromCache(id){
    return this._fileCache[id]
  }

  async getFile(path){
    await this.getIndex()

    if(!(this.index &amp;&amp; this.index.objects)){
      return null
    }

    path = Path.join('/', path)

    let fileId = null
    for(const obj of this.index.objects){
      if(obj.path == path){
        fileId = obj.objectId.id
        break;
      }
    }

    if(!fileId){ return null }

    //! get file from cache
    let file = this._fileCache[fileId]

    if(!file){
      file = new GpgFsFile({
        bucket: this,
        id: fileId,
        filePath: path
      })

      await file.open()
      this._fileCache[file.id] = file
    }

    return file
  }

  get path(){ return '/buckets/bucket-'+this.id.toHexString() }
  get indexPath(){return this.path+'/index' }
  get metadataPath(){return this.path+'/metadata' }

  async getReciepents(){
    await this.root.cacheWhoami()
    let toList = [ this.root.whoami ]

    if(this.metadata){

      if(this.metadata.meta &amp;&amp; this.metadata.meta.length > 0){
        toList = toList.concat(this.metadata.meta)
      }

      if(this.metadata.readers &amp;&amp; this.metadata.readers.length > 0){
        toList = toList.concat(this.metadata.readers)
      }

      if(this.metadata.writers &amp;&amp; this.metadata.writers.length > 0){
        toList = toList.concat(this.metadata.writers)
      }

    }

    return Utils.uniqueArray(toList)
  }

  async getObjectIds(){
    const objectPaths = (await this.readDir('/objects'))
      .map(item=>{
        return item.replace('object-','')
      })

    debug('found ids', objectPaths)
    return objectPaths
  }

  /**
   * Bucket index 
   * @method 
   * @returns {gpgfs_model.bucket_index} See [`gpgfs_model.bucket_index`]{@link https://github.com/datapartyjs/gpgfs-model/blob/master/src/types/bucket_index.js}
   */
  async getIndex(){
    if(this.index !== null){ return this.index }
    const indexPath = this.path + '/index'
    this.index = await this.root.readFile( indexPath, true, 'bucket_index')
    return this.index   
  }

  /**
   * Bucket metadata 
   * @method 
   * @returns {gpgfs_model.bucket_meta} See [`gpgfs_model.bucket_meta`]{@link https://github.com/datapartyjs/gpgfs-model/blob/master/src/types/bucket_meta.js}
   */
  async getMetadata(){
    const metadataPath = this.path + '/metadata'
    this.metadata = await this.root.readFile( metadataPath, true, 'bucket_meta')
    return this.metadata
  }

  async setMetadata(value){
    const nowTime = (new Date()).toISOString()
    let newMetadata = Object.assign({lastchanged: nowTime}, this.metadata, value)

    await this.root.writeFile( this.path + '/metadata',
      newMetadata,
      {
        model: 'bucket_meta',
        encrypt: true,
        to: await this.getReciepents()
      }
    )

    if(!this.metadata){
      debug('creating metadata')
      this.metadata = newMetadata
    }
    else {
      debug('replacing metadata')
      this.metadata = newMetadata
    }
  }


  async setIndex(value){
    const nowTime = (new Date()).toISOString()
    let newIndex = Object.assign({
      lastchanged: nowTime,
      bucketId: {
        id: this.id.toHexString(),
        type: 'bucket_meta'
      },
      objects: []
    }, value)


    await this.root.writeFile( this.path + '/index',
      newIndex,
      {
        model: 'bucket_index',
        encrypt: true,
        to: await this.getReciepents()
      }
    )

    if(!this.index){
      debug('creating index')
      this.index = newIndex
    }
    else {
      debug('replacing index')
      this.index = newIndex
    }
  }

  /** @method
   * @param {File} file
   */
  async indexFile(file){
    let indexes = []

    await this.getIndex()


    for(const idx in Hoek.reach(this, 'index.objects')){
      
      let obj = this.index.objects[ idx ]
      if(obj.path == file.filePath || obj.objectId.id == file.id){
        indexes.push(idx)
      }
    }

    debug('found ', indexes.length, ' index entries matching path =', file.filePath)

    if(indexes.length > 1){ throw new Error('duplicate file path in index') }

    const idx = indexes[0]
    let oldIndex =  Hoek.reach(this, 'index.objects.'+idx)
    let newIndex = {
      created: file.metadata.created,
      objectId: file.metadata.objectId,
      path: file.metadata.path,
      size: file.lastchange.size,
      lastchanged: file.lastchange.lastchanged
    }

    debug('newIndex', newIndex)

    if(!oldIndex){
      await this.setIndex({
        ...this.index,
        objects: [].concat(this.index.objects, [newIndex])
      })
    }
    else {

      this.index.objects[ idx ] = newIndex
      await this.setIndex({...this.index })
    }
  }

  async unindexFile(file){
    debug('unindex')
    let indexes = []

    await this.getIndex()


    for(const idx in Hoek.reach(this, 'index.objects')){
      
      let obj = this.index.objects[ idx ]
      if(obj.path == file.filePath || obj.objectId.id == file.id){
        indexes.push(idx)
      }
    }

    debug('found ', indexes.length, ' index entries matching path =', file.filePath)

    if(indexes.length > 1){ throw new Error('duplicate file path in index') }

    const idx = indexes[0]
    let oldIndex =  Hoek.reach(this, 'index.objects.'+idx)

    if(oldIndex){
      debug('removing from index', oldIndex)
      this.index.objects.splice( idx, 1 );

      await this.setIndex({...this.index })
    }
  }
}

module.exports = Bucket</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> on Wed Jan 15 2020 19:18:37 GMT-0800 (Pacific Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
